#define REORGANIZE_INDICES false
#define CHUNKIFY_WITH_CSHADER false

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeNoise
#pragma kernel MarchingCubes
#pragma kernel ChunkifyCells

#if CHUNKIFY_WITH_CSHADER
#pragma kernel ChunkifyMeshes
#endif

#include "Utils.compute"
#include "MarchingCubeConstants.compute"
#include "NoiseGenerationUtils.compute"
#include "ChunkUtils.compute"




//structs
struct NoiseLayer3D
{
    float LayerWeigth;
    
    int GradientOffset;
    int NoiseScale;
    
    int UseSmootherStep;
};

struct CubeMesh
{
    float3 Vertices[12];
    int Triangles[12];
};

struct ChunkMesh
{
    float3 Vertices[12 * CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE];
    int VerticesCount;
    int Triangles[12 * CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE];
    int TrianglesCount;
};


RWTexture3D<float> _NoiseTexture;

RWStructuredBuffer<CubeMesh> _GeneratedCells;
RWStructuredBuffer<ChunkMesh> _GeneratedChunks;

uint3 _ChunkZoneSizeToGenerate;
int3 _ChunkOffset;

float _Threshold;

// Noise Params
uint _NoiseLayersCount;
StructuredBuffer<NoiseLayer3D> _NoiseLayers;

float _NoiseWeigthsMultiplier;


float ComputeNoiseForCoordinates(uint ix, uint iy, uint iz)
{
    float value = 0;
    
    for (uint i = 0; i < _NoiseLayersCount; i++)
    {
        NoiseLayer3D currentLayer = _NoiseLayers[i];
        int noiseScale = currentLayer.NoiseScale;
        int offset = currentLayer.GradientOffset;
        bool smootherstep = currentLayer.UseSmootherStep == 1;
        
        float x = float(ix) / noiseScale;
        float y = float(iy) / noiseScale;
        float z = float(iz) / noiseScale;
    
        // Determine grid cell coordinates
        int x0 = int(floor(x));
        int x1 = x0 + 1;
        int y0 = int(floor(y));
        int y1 = y0 + 1;
        int z0 = int(floor(z));
        int z1 = z0 + 1;
 
        // Determine interpolation weights
        // Could also use higher order polynomial/s-curve here
        float sx = x - (float) x0;
        float sy = y - (float) y0;
        float sz = z - (float) z0;
 
        // Interpolate between grid point gradients
        float n0 = DotGridGradient(x0, y0, z0, x, y, z, offset);
        float n1 = DotGridGradient(x1, y0, z0, x, y, z, offset);
        float iy0z0 = Interpolate(n0, n1, sx, smootherstep);
        
        n0 = DotGridGradient(x0, y1, z0, x, y, z, offset);
        n1 = DotGridGradient(x1, y1, z0, x, y, z, offset);
        float iy1z0 = Interpolate(n0, n1, sx, smootherstep);
        
        float iz0 = Interpolate(iy0z0, iy1z0, sy, smootherstep);
        
        n0 = DotGridGradient(x0, y0, z1, x, y, z, offset);
        n1 = DotGridGradient(x1, y0, z1, x, y, z, offset);
        float iy0z1 = Interpolate(n0, n1, sx, smootherstep);
        
        n0 = DotGridGradient(x0, y1, z1, x, y, z, offset);
        n1 = DotGridGradient(x1, y1, z1, x, y, z, offset);
        float iy1z1 = Interpolate(n0, n1, sx, smootherstep);
        
        float iz1 = Interpolate(iy0z1, iy1z1, sy, smootherstep);
        
        float layerValue = Interpolate(iz0, iz1, sz, smootherstep);
    
        layerValue = layerValue / 2 + 0.5f;
        
        value += layerValue * currentLayer.LayerWeigth * _NoiseWeigthsMultiplier;
    }
    return value;
}

[numthreads(8, 8, 8)]
void ComputeNoise(uint3 id : SV_DispatchThreadID)
{
    uint3 offset = _ChunkOffset * CHUNK_SIZE;
    float value = ComputeNoiseForCoordinates(id.x + offset.x, id.y + offset.y, id.z + offset.z);
    _NoiseTexture[id.xyz] = value;
}



[numthreads(8, 8, 8)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    uint index = CoordinatesToChunkifiedIndex(id.xyz, _ChunkZoneSizeToGenerate);
    CubeMesh mesh;
    float3 meshVertices[12] = _DefaultVertices;
    int meshTriangles[12] = _DefaultTriangles;
    
    uint3 localCoordinates = CoordinatesToLocalCoordinates(id.xyz);
    uint cellID = LocalCoordinatesToChunkifiedLocalOffset(localCoordinates) * 12;
    
    
    // Determine the index in _TriangleTable of the current mesh
    uint meshIndex = 0;
    for (int i = 0; i < 8; i++)
    {
        if (_NoiseTexture[id.xyz + _VerticesCoordinates[i]] < _Threshold)
        {
            meshIndex |= 1 << i;
        }
    }
    
    meshTriangles = _TriangleTable[meshIndex];
    
    for (int j = 0; j < 12; j++)
    {
        int rawVertexIndex = meshTriangles[j];
        if (rawVertexIndex == -1)
        {
            break;
        }
        
        uint3 cubeCoordsOffset = _CubeContainingVertexOffset[rawVertexIndex];
        bool isVertexInsideChunk = IsInsideChunk(localCoordinates + cubeCoordsOffset);
        bool isVertexInThisCell = Equals(cubeCoordsOffset, uint3(0, 0, 0)) || !isVertexInsideChunk;
        
        
        if (!isVertexInThisCell)
        {
            rawVertexIndex = _VertexEquivalentInContainingCube[rawVertexIndex];
            meshTriangles[j] = rawVertexIndex + cellID + LocalCoordinatesToChunkifiedLocalOffset(cubeCoordsOffset) * 12;
        }
        else
        {
            meshTriangles[j] += cellID;
        }
        
        if (isVertexInThisCell && Equals(meshVertices[rawVertexIndex], _EmptyVertice))
        {
            int2 edgeVertexIndices = _EdgeVertexIndices[rawVertexIndex];
            float2 noiseValues = float2(_NoiseTexture[id.xyz + _VerticesCoordinates[edgeVertexIndices.x]], _NoiseTexture[id.xyz + _VerticesCoordinates[edgeVertexIndices.y]]);
            float lerpFactor = abs((_Threshold - noiseValues.x) / (noiseValues.x - noiseValues.y));
            
            float3 vertexPos = lerp(_VerticesCoordinates[edgeVertexIndices.x], _VerticesCoordinates[edgeVertexIndices.y], lerpFactor);
            meshVertices[rawVertexIndex] = vertexPos;
            
        }
        
#if REORGANIZE_INDICES
        if (isExtVertex)
        {
            meshTriangles[j] += cellID;
        }
        else
        {
            meshTriangles[j] += LocalCoordinatesToChunkifiedLocalOffset(localCoordinates + cubeCoordsOffset) * 12;
        }
#else
#endif
    }
    
    mesh.Vertices = meshVertices;
    mesh.Triangles = meshTriangles;
    _GeneratedCells[index] = mesh;
}

void ChunkifyCellsForChunk(uint chunkIndex)
{
    uint chunkOffset = chunkIndex * CHUNK_VOLUME;

    float3 chunkVertices[12 * CHUNK_VOLUME];
    int chunkTriangles[12 * CHUNK_VOLUME];

    int vertexMap[12 * CHUNK_VOLUME];
    int nextVertexIndex = 0;
    int nextTriangleIndex = 0;

    for (int i = 0; i < CHUNK_VOLUME; ++i)
    {
        CubeMesh currentMesh = _GeneratedCells[chunkOffset + i];
        float3 currentVertices[12] = currentMesh.Vertices;
        int currentTriangles[12] = currentMesh.Triangles;

        int currentMeshMinVerticeIndex = i * 12;
        int currentMeshMaxVerticeIndex = (i + 1) * 12 - 1;

        for (uint j = 0; j < 12; j++)
        {
            int rawVertexIndex = currentTriangles[j];
            if (rawVertexIndex == -1)
            {
                break;
            }


            if (Between(rawVertexIndex, currentMeshMinVerticeIndex, currentMeshMaxVerticeIndex))
            {
                if (vertexMap[rawVertexIndex] == 0)
                {
                    chunkVertices[nextVertexIndex++] = currentVertices[rawVertexIndex % 12] + GetCoordinatesFromIndex(rawVertexIndex / 12, uint3(1, 1, 1) * CHUNK_SIZE);

                    vertexMap[rawVertexIndex] = nextVertexIndex;
                }
            }
        }
    }

    for (i = 0; i < CHUNK_VOLUME; ++i)
    {
        int currentTriangles[12] = _GeneratedCells[chunkOffset + i].Triangles;
        
        for (uint j = 0; j < 12; j++)
        {
            int rawVertexIndex = currentTriangles[j];
            if (rawVertexIndex == -1)
            {
                break;
            }
            chunkTriangles[nextTriangleIndex++] = vertexMap[rawVertexIndex] - 1;
        }
    }

    ChunkMesh chunk;
    chunk.Vertices = chunkVertices;
    chunk.VerticesCount = nextVertexIndex;
    chunk.Triangles = chunkTriangles;
    chunk.TrianglesCount = nextTriangleIndex;

    _GeneratedChunks[chunkIndex] = chunk;
}

[numthreads(1, 1, 1)]
void ChunkifyCells(uint3 id : SV_DispatchThreadID)
{
    ChunkifyCellsForChunk(id.x + id.y * _ChunkZoneSizeToGenerate.x + id.z * _ChunkZoneSizeToGenerate.x * _ChunkZoneSizeToGenerate.y);
}
