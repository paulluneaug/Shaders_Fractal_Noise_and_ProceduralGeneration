// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PerlinNoise

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _Result;

int _GradientOffet;

int _GradientSizeX;
int _GradientSizeY;

bool _SmootherStep;

float Smoothstep(float w)
{
    w = clamp(w, 0.0f, 1.0f);
    return w * w * (3.0f - 2.0f * w);
}

float Smootherstep(float w)
{
    w = clamp(w, 0.0f, 1.0f);
    return ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w);
}

float Interpolate(float a0, float a1, float w)
{
    //return (a1 - a0) * w + a0;
    float smoothW = 0;
    if (_SmootherStep)
    {
        smoothW = Smootherstep(w);
    }
    else
    {
        smoothW = Smoothstep(w);
    }

    return a0 + (a1 - a0) * smoothW;
}

float2 RandomGradient(int ix, int iy)
{
    // No precomputed gradients mean this works for any number of grid coordinates
    uint w = 8 * 4;
    uint s = w / 2; // rotation width
    uint a = ix, b = iy;
    a *= 3284157443;
    b ^= a << s | a >> w - s;
    b *= 1911520717 - abs(_GradientOffet);
    a ^= b << s | b >> w - s;
    a *= 2048419325;
    float random = a * (3.14159265 / ~(~0u >> 1)); // in [0, 2*Pi]
    
    return float2(cos(random), sin(random));
}

float DotGridGradient(int ix, int iy, float x, float y)
{
    float2 randomVec = RandomGradient(ix, iy);
    
    // Compute the distance vector
    float dx = x - (float) ix;
    float dy = y - (float) iy;
 
    // Compute the dot-product
    return (dx * randomVec.x + dy * randomVec.y);
}

[numthreads(8,8,1)]
void PerlinNoise (uint3 id : SV_DispatchThreadID)
{
    float x = float(id.x) / _GradientSizeX;
    float y = float(id.y) / _GradientSizeY;
    
    // Determine grid cell coordinates
    int x0 = int(floor(x));
    int x1 = x0 + 1;
    int y0 = int(floor(y));
    int y1 = y0 + 1;
 
    // Determine interpolation weights
    // Could also use higher order polynomial/s-curve here
    float sx = x - (float)x0;
    float sy = y - (float)y0;
 
    // Interpolate between grid point gradients
    float n0 = DotGridGradient(x0, y0, x, y);
    float n1 = DotGridGradient(x1, y0, x, y);
    float ix0 = Interpolate(n0, n1, sx);
    n0 = DotGridGradient(x0, y1, x, y);
    n1 = DotGridGradient(x1, y1, x, y);
    float ix1 = Interpolate(n0, n1, sx);
    float value = Interpolate(ix0, ix1, sy);
    
    value = value / 2 + 0.5f;

    _Result[id.xy] = float4(value, value, value, 1);
    //_Result[id.xy] = float4(float(x0) / (_GradientSizeX), float(y0) / (_GradientSizeY), value, 1);

}
